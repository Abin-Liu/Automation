<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Automation</name>
    </assembly>
    <members>
        <member name="T:Automation.AutomationForm">
            <summary>
            A Form derived class controls AutomationThread
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.HideMainForm">
            <summary>
            Whether hide main form (using a notification icon?)
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.IsAlive">
            <summary>
            Whether the thread is running
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.Aborted">
            <summary>
            Whether the thread was stopped by user
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.TargetWnd">
            <summary>
            Handle of the target window
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.SetThread(Automation.AutomationThread)">
            <summary>
            Set the thread member
            <param name="thread">An object derived from AutomationThread</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.StartThread">
            <summary> 
            Start the thread
            <returns>Return true if the thread starts successfully, false otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.StopThread">
            <summary>
            Stop the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.ToggleThread">
            <summary>
            Toggle the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.ShowForm">
            <summary>
            显示本窗口并置于前台
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadStart">
            <summary>
            Thread started
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadAbort">
            <summary>
            Thread aborted
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadStop">
            <summary>
            Thread stopped
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnHotKey(System.Int32)">
            <summary>
            The user pressed a registered hotkey
            <param name="id">Hotkey id</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadMessage(System.Int32,System.Int32)">
            <summary>
            Event received from the thread
            <param name="wParam">wParam</param>
            <param name="lParam">lParam</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnMessage(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Generic event received
            <param name="message">Message id</param>
            <param name="wParam">wParam</param>
            <param name="lParam">lParam</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.RegisterHotKey(System.Int32,System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary>
            Register a hotkey, whenever the user presses it, the form will be notified
            <param name="id">Hotkey id</param>
            <param name="key">Key value</param>
            <param name="mods">Modifiers（Ctrl, Alt, Shift）, can be combined with | operator</param>
            <returns>Return true if success, false otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.UnregisterHotKey(System.Int32)">
            <summary>
            Unregister a hotkey
            <param name="id">Hotkey id</param>		
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Override WndProc
            <param name="m">Message struct</param>		
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.AutomationForm_Load(System.Object,System.EventArgs)">
            <summary>
            Called upon Load event
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.AutomationForm_FormClosing(System.Object,System.Windows.Forms.FormClosingEventArgs)">
            <summary>
            Called upon FormClosing event
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.AutomationForm_FormClosed(System.Object,System.Windows.Forms.FormClosedEventArgs)">
            <summary>
            Called upon FormClosed event
            </summary>
        </member>
        <member name="T:Automation.AutomationThread">
            <summary>
            The abstract thread class interact with the target window
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.TargetWnd">
            <summary>
            Handle of the target window
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.HasTargetWnd">
            <summary>
            Checks whether there's a target window
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ClientRect">
            <summary> 
            Client rectangle of the target window, top-left is always 0,0
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ClientToScreen">
            <summary> 
            Win32 ClientToScreen offset
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ScreenToClient">
            <summary> 
            Win32 ScreenToClient offset
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ForegroundMode">
            <summary>
            Auto foregrounding mode
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.LastError">
            <summary> 
            Thread error messages used by message window
            </summary> 
        </member>
        <member name="P:Automation.AutomationThread.Alerting">
            <summary> 
            Start or stop sound alarm
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.IsAlive">
            <summary> 
            Whether the thread is running
            </summary> 
        </member>
        <member name="P:Automation.AutomationThread.Aborted">
            <summary> 
            Whether the thread was aborted by user
            </summary> 
        </member>
        <member name="P:Automation.AutomationThread.StartTime">
            <summary>
            Time when thread started
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.EndTime">
            <summary>
            Time when thread ended
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.RunTime">
            <summary>
            Total time the thread had run, in seconds
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.RunTimeText">
            <summary>
            Total time the thread had run, in "H:mm:ss" format
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.RoundCount">
            <summary>
            Rounds processed (derived classes will define what a round is)
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.SecondsPerRound">
            <summary>
            Average number of seconds a round takes
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.#ctor">
            <summary> 
            Default constructor
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Finalize">
            <summary> 
            Destructor
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Start(System.Windows.Forms.Form)">
            <summary> 
            Start the thread
            <param name="messageForm">The window which receives thread messages, usually the main form</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Stop">
            <summary> 
            Stop the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Sleep(System.Int32)">
            <summary> 
            Sleep the current thread
            <param name="milliseconds">Milliseconds</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Lock(System.Object)">
            <summary> 
            Sync lock
            <param name="locker">Object to lock, use internal locker if null</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Unlock(System.Object)">
            <summary> 
            Sync unlock
            <param name="locker">Object to unlock, use internal locker if null</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Beep(System.Boolean)">
            <summary>
            Play a short prompting beep sound
            </summary>
            <param name="start">Play start.wav is true, play stop.wav otherwise</param>
        </member>
        <member name="M:Automation.AutomationThread.FindTargetWnd">
            <summary>
            Find handle of the target window which the thread is dealing with
            </summary>
            <returns>Handle of the target window, or IntPtr.Zero if not exists</returns>
        </member>
        <member name="M:Automation.AutomationThread.PreStart">
            <summary> 
            A callback checking before the thread starts
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.OnStart">
            <summary> 
            Thread started
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.OnStop">
            <summary> 
            Thread stopped
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.ThreadProc">
            <summary> 
            Thread work
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.PostMessage(System.Int32,System.Int32)">
            <summary> 
            Send a message to the message window
            <param name="wParam">wParam</param> 
            <param name="lParam">lParam</param> 		/// 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.PrepareTargetWnd">
            <summary>
            Update target window and make sure it's foreground, also reset cursor location
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.UpdateTargetWnd">
            <summary>
            Retrieve/update target window handle
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.FindWindow(System.String,System.String)">
            <summary>
            Static method to find a window using class and title
            </summary>
            <param name="windowClass">Class name of the window, null to ignore</param>
            <param name="windowName">Window title of the window, null to ignore</param>
            <returns>Return target window handle</returns>
        </member>
        <member name="M:Automation.AutomationThread.IsTargetWndForeground">
            <summary> 
            Whether the target window is foreground
            <returns>Return true if the target window is foreground, false otherwise</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.SetTargetWndForeground">
            <summary> 
            Set the target window foreground		
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.WaitTargetWndForeground">
            <summary>
            Wait until the target window is foreground
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.GetPixel(System.Int32,System.Int32)">
            <summary> 
            Read pixel RGB value from client area of the target window.
            <param name="x">X coords (relative to client).</param>
            <param name="y">Y coords (relative to client).</param>
            <returns>Return RGB value if success, 0 otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.WaitForPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> 
            Keeps checking whether a pixel of the target window matches specified RGB values
            <param name="x">X coords (relative to client)</param> 
            <param name="y">Y coords (relative to client)</param> 
            <param name="color">The RGB value</param> 
            <param name="timeout">Maximum milliseconds before timeout, 0 to check infinitely</param>
            <param name="sleep">Sleep the running thread between two checks, in millisecond (minimum is 100ms) </param>
            <returns>Return true if the pixel matches before timeout, false otherwise</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.RGB(System.Byte,System.Byte,System.Byte)">
            <summary>
            Compose rgb values into an integer
            </summary>
            <param name="r">Value of r component</param>
            <param name="g">Value of g component</param>
            <param name="b">Value of b component</param>
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:Automation.AutomationThread.RGB(System.Drawing.Color)">
            <summary>
            Compose rgb values into an integer, unlike System.Drawing.Color, it eliminates alpha value
            </summary>
            <param name="color">Value of color</param>		
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:Automation.AutomationThread.GetRValue(System.Int32)">
            <summary>
            Extract the r component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the r component</returns>
        </member>
        <member name="M:Automation.AutomationThread.GetGValue(System.Int32)">
            <summary>
            Extract the g component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the g component</returns>
        </member>
        <member name="M:Automation.AutomationThread.GetBValue(System.Int32)">
            <summary>
            Extract the b component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the b component</returns>
        </member>
        <member name="M:Automation.AutomationThread.ExamPixel(System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Check pixel color with tolerances
            </summary>
            <param name="color">Color to be checked</param>
            <param name="rangeR">Tolerance range [min, max] for R value, null to ignore R value check</param>
            <param name="rangeG">Tolerance range [min, max] for G value, null to ignore G value check</param>
            <param name="rangeB">Tolerance range [min, max] for B value, null to ignore B value check</param>
            <returns>Return true if the pixel passed, false otherwise</returns>
        </member>
        <member name="M:Automation.AutomationThread.TranslateLocation(System.Int32,System.Int32)">
            <summary> 
            Client coords to screen coords
            <param name="x">Client x coords</param> 
            <param name="y">Client y coords</param> 
            <returns>Screen coords</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.TranslateLocation(System.Drawing.Point)">
            <summary> 
            Client coords to screen coords
            <param name="point">Client coords</param> 
            <returns>Screen coords</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.CursorInClient">
            <summary>
            Checks wether cursor in in target client rectangle
            </summary>
            <returns>Return true if cursor is in client rectangle, false otherwise</returns>
        </member>
        <member name="M:Automation.AutomationThread.ResetMouse">
            <summary>
            Put mouse cursor to a safe location to avoid triggering any unexpected elements
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseClick(System.Int32,System.Int32,System.Windows.Forms.MouseButtons)">
            <summary> 
            Click a mouse button inside the target window's client area
            <param name="x">Client x coords</param> 
            <param name="y">Client y coords</param> 
            <param name="button">Mouse button</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseMove(System.Int32,System.Int32)">
            <summary> 
            Move the cursor to the target window's client area
            <param name="x">Client x coords</param> 
            <param name="y">Client y coords</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseDrag(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.MouseButtons)">
            <summary>
            Drag the mouse from one position to another
            </summary>
            <param name="x1">X coords of the start position</param>
            <param name="y1">Y coords of the start position</param>
            <param name="x2">X coords of the end position</param>
            <param name="y2">Y coords of the end position</param>
            <param name="button">The button to be held down</param>
        </member>
        <member name="M:Automation.AutomationThread.MouseDown(System.Windows.Forms.MouseButtons)">
            <summary> 
            Press down a mouse button
            <param name="button">Mouse button</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseUp(System.Windows.Forms.MouseButtons)">
            <summary> 
            Release a mouse button
            <param name="button">Mouse button</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseWheel(System.Boolean)">
            <summary> 
            Scroll the mouse wheel
            <param name="scrollUp">Wheel direction</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyStroke(System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary> 
            Send a keystroke	
            <param name="key">Keys value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyStroke(System.String,System.Int32)">
            <summary> 
            Send a sequence of keystokes		
            <param name="keys">The string defines keys to be sent, same format as System.Windows.SendKeys</param>
            <param name="delay">Delay between each 2 key, in milliseconds</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyDown(System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary> 
            Press a key		
            <param name="key">Keys value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyUp(System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary> 
            Release a key		
            <param name="key">Keys value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.IsKeyDown(System.Windows.Forms.Keys)">
            <summary>
            Check whether a key is currently held down
            </summary>
            <param name="key">Keys value</param>
            <returns>Return true if the specified key is held down, false otherwise.</returns>
        </member>
        <member name="M:Automation.AutomationThread.Dispose">
            <summary> 
            Dispose the object
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Dispose(System.Boolean)">
            <summary> 
            Release unmanaged resources such as device context
            </summary>
        </member>
        <member name="T:Automation.ForegroundModes">
            <summary>
            Target window auto foregrounding mode
            </summary>
        </member>
        <member name="F:Automation.ForegroundModes.Never">
            <summary>
            Never auto foregrounding
            </summary>
        </member>
        <member name="F:Automation.ForegroundModes.Always">
            <summary>
            Always auto foregrounding
            </summary>
        </member>
        <member name="F:Automation.ForegroundModes.CursorInClient">
            <summary>
            Only auto foregrounding when cursor is in client rectangle
            </summary>
        </member>
        <member name="T:Automation.Utils.LangBase">
            <summary>
            Base class for localization
            </summary>
        </member>
        <member name="P:Automation.Utils.LangBase.Name">
            <summary>
            Locale name
            </summary>
        </member>
        <member name="P:Automation.Utils.LangBase.Contents">
            <summary>
            Text dictionary
            </summary>
        </member>
        <member name="T:Automation.Utils.LangManager">
            <summary>
            Localization
            </summary>
        </member>
        <member name="M:Automation.Utils.LangManager.Get(System.String)">
            <summary>
            Query for a localized string
            </summary>
            <param name="key">Query key</param>
            <returns>Returns the localized string, or the key itself if not exists</returns>
        </member>
        <member name="M:Automation.Utils.LangManager.#cctor">
            <summary>
            Static c'tor
            </summary>
        </member>
        <member name="M:Automation.Utils.LangManager.CreateAllLocales">
            <summary>
            从程序集中创建所有继承自BaseLocale类型的对象
            </summary>
            <returns>对象列表</returns>
        </member>
        <member name="M:Automation.Utils.LangManager.Register(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Register a new locale
            </summary>
            <param name="name">Locale name</param>
            <param name="contents">String set for the locale</param>
        </member>
        <member name="T:Automation.Locales.zhCN">
            <summary>
            Chinese simplified
            </summary>
        </member>
        <member name="P:Automation.Locales.zhCN.Name">
            <summary>
            Local name
            </summary>
        </member>
        <member name="P:Automation.Locales.zhCN.Contents">
            <summary>
            Text dictionary
            </summary>
        </member>
        <member name="T:Automation.Locales.zhTW">
            <summary>
            Chinese traditional
            </summary>
        </member>
        <member name="P:Automation.Locales.zhTW.Name">
            <summary>
            Local name
            </summary>
        </member>
        <member name="P:Automation.Locales.zhTW.Contents">
            <summary>
            Text dictionary
            </summary>
        </member>
        <member name="T:Automation.MemDC">
            <summary>
            The GDI GetPixel method only suits for single pixel fetching, and will freeze 
            the screen if a whole region of pixels need to be scanned quickly. ClientDC
            copies a region of pixels from client area to memory then access them, this solution
            improves the performance by hundreds times. It can also capture pixels of directX
            windows.
            </summary>
        </member>
        <member name="F:Automation.MemDC.COLOR_INVALID">
            <summary>
            Represents an invalid color value, 0xffffffff in Win32
            </summary>
        </member>
        <member name="P:Automation.MemDC.Bitmap">
            <summary>
            The underlying Bitmap object
            </summary>
        </member>
        <member name="P:Automation.MemDC.Valid">
            <summary>
            Checks whether the object is valid
            </summary>
        </member>
        <member name="P:Automation.MemDC.Width">
            <summary>
            Width of the underlying bitmap
            </summary>
        </member>
        <member name="P:Automation.MemDC.Height">
            <summary>
            Height of the underlying bitmap
            </summary>
        </member>
        <member name="M:Automation.MemDC.Dispose">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="M:Automation.MemDC.Cleanup">
            <summary>
            Free resource
            </summary>
        </member>
        <member name="M:Automation.MemDC.Capture(System.Drawing.Rectangle)">
            <summary>
            Capture a block of pixels from screen to memory
            </summary>
            <param name="rect">Boundary of data block</param>
            <returns>Return true if success, false otherwise</returns>
        </member>
        <member name="M:Automation.MemDC.Capture(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Capture a block of pixels from screen to memory
            </summary>
            <param name="x">X coord of screen</param>
            <param name="y">Y coord of screen</param>
            <param name="width">Width of data block</param>
            <param name="height">Height of data block</param>
            <returns>Return true if success, false otherwise</returns>
        </member>
        <member name="M:Automation.MemDC.GetPixel(System.Int32,System.Int32)">
            <summary> 
            Read pixel RGB value from data block.
            <param name="x">X coords of mem dc.</param>
            <param name="y">Y coords of mem dc.</param>
            <returns>Return RGB value if success, COLOR_INVALID otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.MemDC.CaptureAndGetPixel(System.Int32,System.Int32)">
            <summary>
            Capture single pixel and read it
            </summary>
            <param name="x">X coords of screen.</param>
            <param name="y">Y coords of screen.</param>
            <returns>Return RGB value if success, COLOR_INVALID otherwise.</returns>
        </member>
        <member name="M:Automation.MemDC.ExamPixel(System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Check pixel color with tolerances
            </summary>
            <param name="color">Color to be checked</param>
            <param name="rangeR">Tolerance range [min, max] for R value, null to ignore R value check</param>
            <param name="rangeG">Tolerance range [min, max] for G value, null to ignore G value check</param>
            <param name="rangeB">Tolerance range [min, max] for B value, null to ignore B value check</param>
            <returns>Return true if the pixel passed, false otherwise</returns>
        </member>
        <member name="M:Automation.MemDC.WaitForPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> 
            Keeps checking whether a pixel of the target window matches specified RGB values
            <param name="x">X coords of screen</param> 
            <param name="y">Y coords of screen</param> 
            <param name="color">The RGB value</param> 
            <param name="timeout">Maximum milliseconds before timeout, 0 to check infinitely</param>
            <param name="sleep">Sleep the running thread between two checks, in millisecond (minimum is 100ms) </param>
            <returns>Return true if the pixel matches before timeout, false otherwise</returns>
            </summary>
        </member>
        <member name="T:Automation.MemDC.ScanPixelDelegate">
            <summary>
            Delegate used for pixel scanning
            </summary>
            <param name="x">The x coords relative to bitmap</param>
            <param name="y">The y coords relative to bitmap</param>
            <param name="pixel">RGB value of the pixel at (x,y)</param>
            <param name="parameter">Callback parameter</param>
            <returns>Return true to abort the scanning, false to proceed with next pixel</returns>
        </member>
        <member name="M:Automation.MemDC.ScanPixels(Automation.MemDC.ScanPixelDelegate,System.Object,System.Int32)">
            <summary>
            Scan pixels
            </summary>
            <param name="callback">Callback function</param>
            <param name="parameter">Callback parameter</param>
            <param name="interlace">Scanning interlace for both horizontal and vertical, 0 means scan every pixel</param>
            <returns>Returns true if the last callback returned true, or false if all pixels have been scanned</returns>
        </member>
        <member name="M:Automation.MemDC.Save(System.String)">
            <summary> 
            Save the memory block to a file, image formats are automatically determined by file extension.
            <param name="filePath">Destination file path, will be overwritten if exists.</param>
            </summary>
        </member>
        <member name="M:Automation.MemDC.RGB(System.Byte,System.Byte,System.Byte)">
            <summary>
            Compose rgb values into an integer
            </summary>
            <param name="r">Value of r component</param>
            <param name="g">Value of g component</param>
            <param name="b">Value of b component</param>
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:Automation.MemDC.RGB(System.Drawing.Color)">
            <summary>
            Compose rgb values into an integer, unlike System.Drawing.Color, it eliminates alpha value
            </summary>
            <param name="color">Value of color</param>		
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:Automation.MemDC.GetRValue(System.Int32)">
            <summary>
            Extract the r component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the r component</returns>
        </member>
        <member name="M:Automation.MemDC.GetGValue(System.Int32)">
            <summary>
            Extract the g component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the g component</returns>
        </member>
        <member name="M:Automation.MemDC.GetBValue(System.Int32)">
            <summary>
            Extract the b component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the b component</returns>
        </member>
        <member name="T:Automation.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Automation.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Automation.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Automation.Resources.Alert">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="P:Automation.Resources.Start">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="P:Automation.Resources.Stop">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="T:Automation.ThreadAlreadyRunningException">
            <summary>
            异常定义：线程已经在运行中
            </summary>
        </member>
        <member name="M:Automation.ThreadAlreadyRunningException.#ctor">
            <summary>
            默认构造函数
            </summary>
        </member>
        <member name="M:Automation.ThreadAlreadyRunningException.#ctor(System.String)">
            <summary>
            带描述构造函数
            </summary>
            <param name="message">异常描述</param>
        </member>
        <member name="T:Automation.TargetWindowNotFoundException">
            <summary>
            异常定义：目标窗口未找到
            </summary>
        </member>
        <member name="M:Automation.TargetWindowNotFoundException.#ctor">
            <summary>
            默认构造函数
            </summary>
        </member>
        <member name="M:Automation.TargetWindowNotFoundException.#ctor(System.String)">
            <summary>
            带描述构造函数
            </summary>
            <param name="message">异常描述</param>
        </member>
        <member name="T:UIToolkits.Locale">
            <summary>
            Key-value map for locale strings
            </summary>
        </member>
        <member name="P:UIToolkits.Locale.Item(System.String)">
            <summary>
            Get or set locale values by key
            </summary>
        </member>
        <member name="T:UIToolkits.LocaleCollection">
            <summary>
            Locale collection
            </summary>
        </member>
        <member name="F:UIToolkits.LocaleCollection.SystemLocale">
            <summary>
            Get system locale: en-US, zh-CN, zh-TW, etc
            </summary>
        </member>
        <member name="M:UIToolkits.LocaleCollection.#ctor">
            <summary>
            Cobstructor
            </summary>
        </member>
        <member name="M:UIToolkits.LocaleCollection.RegisterLocale(System.String)">
            <summary>
            Register a locale if not exists
            <param name="name">Name of the locale, must comply with System.Globalization.CultureInfo</param>
            <returns>The locale object</returns>
            </summary>
        </member>
        <member name="M:UIToolkits.LocaleCollection.GetLocalizedString(System.String)">
            <summary>
            Retrieve a localized string in current system locale
            <param name="key">Key of localized string</param>
            <returns>The locale object</returns>
            </summary>
        </member>
        <member name="T:UIToolkits.Messagex">
            <summary>
            解决MessageBox无法居中显示于父窗体的缺陷
            </summary>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.String)">
            <summary>
            显示消息框
            </summary>
            <param name="text">消息文字</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.String,System.String)">
            <summary>
            显示消息框
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons)">
            <summary>
            显示消息框
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon)">
            <summary>
            显示消息框
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <param name="icon">主题图标</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton)">
            <summary>
            显示消息框
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <param name="icon">主题图标</param>
            <param name="defButton">默认按钮</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton,System.Windows.Forms.MessageBoxOptions)">
            <summary>
            显示消息框
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <param name="icon">主题图标</param>
            <param name="defButton">默认按钮</param>
            <param name="options">显示选项</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.Windows.Forms.IWin32Window,System.String)">
            <summary>
            显示消息框
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary>
            显示消息框
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons)">
            <summary>
            显示消息框
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon)">
            <summary>
            显示消息框
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <param name="icon">主题图标</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton)">
            <summary>
            显示消息框
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <param name="icon">主题图标</param>
            <param name="defButton">默认按钮</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton,System.Windows.Forms.MessageBoxOptions)">
            <summary>
            显示消息框
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <param name="buttons">按钮组合</param>
            <param name="icon">主题图标</param>
            <param name="defButton">默认按钮</param>
            <param name="options">显示选项</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Prompt(System.String,System.String)">
            <summary>
            提示框: 无图标
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Prompt(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary>
            提示框: 无图标
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题，如果为null则使用"Prompt"</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Info(System.String,System.String)">
            <summary>
            提示框: 蓝色i图标
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Info(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary>
            提示框: 蓝色i图标
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Warning(System.String,System.String)">
            <summary>
            提示框: 黄色感叹号图标
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Warning(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary>
            提示框: 黄色感叹号图标
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Error(System.String,System.String)">
            <summary>
            提示框: 红底白叉图标
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Error(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary>
            提示框: 红底白叉图标
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择结果</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Confirm(System.String,System.String)">
            <summary>
            OK/Cancel确认选择框：问号图标
            </summary>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择OK返回true，否则返回false</returns>
        </member>
        <member name="M:UIToolkits.Messagex.Confirm(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary>
            OK/Cancel确认选择框：问号图标
            </summary>
            <param name="owner">要居中显示于的父窗体</param>
            <param name="text">消息文字</param>
            <param name="caption">窗体标题</param>
            <returns>用户选择OK返回true，否则返回false</returns>
        </member>
        <member name="T:Win32API.Hotkey">
            <summary>
            A helper class for system hot key registration
            </summary>
        </member>
        <member name="M:Win32API.Hotkey.RegisterHotKey(System.IntPtr,System.Int32,System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary>
            Register a hotkey
            </summary>
            <param name="hWnd">Handle of the window which will receive WM_HOTKEY event</param>
            <param name="id">Unique identity of the hotkey</param>
            <param name="vk">Key</param>
            <param name="mods">Modifiers, default is none</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Hotkey.UnregisterHotKey(System.IntPtr,System.Int32)">
            <summary>
            Unregister a hotkey
            </summary>
            <param name="hWnd">Handle of the window which was used to register the hotkey</param>
            <param name="id">Unique identity of the hotkey</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Hotkey.IsHotkeyEvent(System.Windows.Forms.Message@)">
            <summary>
            Check whether a window message is a WM_HOTKEY
            </summary>
            <param name="m">The message</param>
            <returns>Return the unique identity of the hotkey if it's a WM_HOTKEY, return -1 otherwise</returns>
        </member>
        <member name="T:Win32API.Input">
            <summary>
            A helper class for keyboard and mouse input simulation
            </summary>
        </member>
        <member name="M:Win32API.Input.MouseMove(System.Int32,System.Int32)">
            <summary>
            Move the mouse to a specified screen location
            </summary>
            <param name="x">X coords (relative to screen)</param>
            <param name="y">Y coords (relative to screen)</param>
        </member>
        <member name="M:Win32API.Input.MouseDrag(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.MouseButtons)">
            <summary>
            Drag the mouse from one position to another
            </summary>
            <param name="x1">X coords of the start position</param>
            <param name="y1">Y coords of the start position</param>
            <param name="x2">X coords of the end position</param>
            <param name="y2">Y coords of the end position</param>
            <param name="button">The button to be held down</param>
        </member>
        <member name="M:Win32API.Input.MouseDown(System.Windows.Forms.MouseButtons)">
            <summary>
            Press down a mouse button
            </summary>
            <param name="button">The button to be pressed</param>
        </member>
        <member name="M:Win32API.Input.MouseUp(System.Windows.Forms.MouseButtons)">
            <summary>
            Release a mouse button
            </summary>
            <param name="button">The button to be released</param>
        </member>
        <member name="M:Win32API.Input.MouseClick(System.Windows.Forms.MouseButtons)">
            <summary>
            Click a mouse button
            </summary>
            <param name="button">The button to be clicked</param>
        </member>
        <member name="M:Win32API.Input.MouseDblClick(System.Windows.Forms.MouseButtons)">
            <summary>
            Double-click a mouse button
            </summary>
            <param name="button">The button to be clicked</param>
        </member>
        <member name="M:Win32API.Input.MouseWheel(System.Boolean)">
            <summary>
            Scroll the mouse wheel
            </summary>
            <param name="scrollUp">Scroll direction</param>
        </member>
        <member name="M:Win32API.Input.ReleaseAllKeys">
            <summary>
            Release all keys if held down
            </summary>
        </member>
        <member name="M:Win32API.Input.IsKeyDown(System.Windows.Forms.Keys)">
            <summary>
            Check whether a specified key is currently held down
            </summary>
            <param name="key">The key</param>
            <returns>Return true if the key is held down, false otherwise</returns>
        </member>
        <member name="M:Win32API.Input.KeyDown(System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary>
            Press down a key
            </summary>
            <param name="key">The key to be pressed down</param>
            <param name="mods">Modifiers</param>
        </member>
        <member name="M:Win32API.Input.KeyUp(System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary>
            Release a key
            </summary>
            <param name="key">The key to be released</param>
            <param name="mods">Modifiers</param>
        </member>
        <member name="M:Win32API.Input.KeyStroke(System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
            <summary>
            Stroke a key
            </summary>
            <param name="key">The key to be stroked</param>
            <param name="mods">Modifiers</param>
        </member>
        <member name="M:Win32API.Input.KeyStroke(System.String,System.Int32)">
            <summary>
            Stoke a sequence of keys defined in "keys"
            </summary>
            <param name="keys">definition of keys, format of which are same with SendKeys</param>
            <param name="delay">delay applied between each keystroke, in milliseconds</param>
        </member>
        <member name="M:Win32API.Input.SetCursorPos(System.Int32,System.Int32)">
            <summary>
            Set cursor pos to specified screen location
            </summary>
            <param name="x">X coords (relative to screen)</param>
            <param name="y">Y coords (relative to screen)</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Input.GetCursorPos">
            <summary>
            Retrieve the cursor location
            </summary>
            <returns>Return a Point struct contains X and Y coords relative to screen</returns>
        </member>
        <member name="T:Win32API.KeyPress">
            <summary>
            简单击键动作
            </summary>
        </member>
        <member name="P:Win32API.KeyPress.Key">
            <summary>
            键值
            </summary>
        </member>
        <member name="P:Win32API.KeyPress.Count">
            <summary>
            按键次数
            </summary>
        </member>
        <member name="M:Win32API.KeyPress.#ctor">
            <summary>
            默认构造函数
            </summary>
        </member>
        <member name="M:Win32API.KeyPress.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="name">表示按键动作的字符串</param>
        </member>
        <member name="M:Win32API.KeyPress.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Win32API.KeyAction">
            <summary>
            复杂击键动作(包含组合键及重复键)
            </summary>
        </member>
        <member name="P:Win32API.KeyAction.Modifiers">
            <summary>
            组合键(多个组合键以|混合)
            </summary>
        </member>
        <member name="P:Win32API.KeyAction.KeyList">
            <summary>
            击键内容
            </summary>
        </member>
        <member name="M:Win32API.KeyAction.Parse(System.String)">
            <summary>
            将字符串解析为击键动作队列
            </summary>
            <param name="text">字符串</param>
            <returns>击键动作队列</returns>
        </member>
        <member name="M:Win32API.KeyAction.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Win32API.Window">
            <summary>
            a helper class for window manipulation
            </summary>
        </member>
        <member name="M:Win32API.Window.FindWindow(System.String,System.String)">
            <summary>
            Find a specified window
            </summary>
            <param name="className">Class name of the window, does not exam if null</param>
            <param name="windowName">Title text of the window, does not exam if null</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Window.IsWindow(System.IntPtr)">
            <summary>
            Check whether a window handle is valid
            </summary>
            <param name="hwnd">The handle to be examed</param>
            <returns></returns>
        </member>
        <member name="T:Win32API.Window.EnumWindowsCallBack">
            <summary>
            Delegate for EnumWindows, it will be called for every window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <param name="lParam">User defined parameter</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Window.EnumWindows(Win32API.Window.EnumWindowsCallBack,System.Int32)">
            <summary>
            Enumerate all top-level windows
            </summary>
            <param name="callback">The delegate to be called when every window is found</param>
            <param name="lParam">User defined parameter</param>
            <returns>Return true if the enumeration completed successfully, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetWindowText(System.IntPtr)">
            <summary>
            Retrieve title text of a window
            </summary>
            <param name="hWnd">Handle of the window</param>
            <returns>Return title text if the handle is valid, null otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetClassName(System.IntPtr)">
            <summary>
            Retrieve class name of a window
            </summary>
            <param name="hWnd">Handle of the window</param>
            <returns>Return class name if the handle is valid, null otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetWindowRect(System.IntPtr)">
            <summary>
            Retrieve boundary rectangle of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return boundary rectangle if the handle is valid, return an empty rectangle otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetClientRect(System.IntPtr)">
            <summary>
            Retrieve boundary rectangle of the client area a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return boundary rectangle of the client area if the handle is valid, return an empty rectangle otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ClientToScreen(System.IntPtr)">
            <summary>
            Retrieve client-to-screen offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ScreenToClient(System.IntPtr)">
            <summary>
            Retrieve screen-to-client offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.WindowToScreen(System.IntPtr)">
            <summary>
            Retrieve window-to-screen offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ScreenToWindow(System.IntPtr)">
            <summary>
            Retrieve screen-to-window offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetForegroundWindow">
            <summary>
            Retrieve the foreground window
            </summary>
            <returns>Handle of the foreground window</returns>
        </member>
        <member name="M:Win32API.Window.SetForegroundWindow(System.IntPtr)">
            <summary>
            Set a window to foreground
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Window.IsMinimized(System.IntPtr)">
            <summary>
            Check whether a window is miminized
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return true if the specified window is minimized, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.IsMaximized(System.IntPtr)">
            <summary>
            Check whether a window is maximized
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return true if the specified window is maxmized, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.IsWindowVisible(System.IntPtr)">
            <summary>
            Check whether a window is visible
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return true if the window is visible, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ShowWindow(System.IntPtr,System.Int32)">
            <summary>
            Display the window in specified way
            </summary>
            <param name="hwnd">Handle of the window</param>
            <param name="nCmdShow">How the window will be displayed</param>
            <returns></returns>
        </member>
        <member name="F:Win32API.Window.SW_HIDE">
            <summary>
            The window will be hidden
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWNORMAL">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_NORMAL">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWMINIMIZED">
            <summary>
            The window will be shown minimized and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWMAXIMIZED">
            <summary>
            The window will be shown maximized and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_MAXIMIZE">
            <summary>
            The window will be shown maximized and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWNOACTIVATE">
            <summary>
            The window will be shown in recent state, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOW">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_MINIMIZE">
            <summary>
            The window will be shown minimized, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWMINNOACTIVE">
            <summary>
            The window will be shown minimized, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWNA">
            <summary>
            The window will be shown in recent state, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_RESTORE">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWDEFAULT">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="M:Win32API.Window.GetDesktopWindow">
            <summary>
            Retrieve handle of the desktop window
            </summary>
            <returns></returns>
        </member>
        <member name="F:Win32API.Window.WM_USER">
            <summary>
            The win32 WM_USER, private window messages should be defined between WM_USER and 0x7FFF
            </summary>
        </member>
        <member name="F:Win32API.Window.WM_APP">
            <summary>
            The win32 WM_APP, global window messages should be defined between WM_APP and 0xBFFF
            </summary>
        </member>
        <member name="M:Win32API.Window.SendMessage(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Send a message to a window, the function will not return until the event handler returns
            </summary>
            <param name="hWnd">Handle of the window which will receive the message</param>
            <param name="Msg">Message identity</param>
            <param name="wParam">Win32 WPARAM</param>
            <param name="lParam">Win32 LPARAM</param>
            <returns>Return the value returned by the event handler</returns>
        </member>
        <member name="M:Win32API.Window.PostMessage(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Post a message to a window, the function returns immediately
            </summary>
            <param name="hWnd">Handle of the window which will receive the message</param>
            <param name="Msg">Message identity</param>
            <param name="wParam">Win32 WPARAM</param>
            <param name="lParam">Win32 LPARAM</param>
            <returns>Return non-zero if the function successful, return zero if failed</returns>
        </member>
        <member name="T:AbinLibs.GenericThread">
            <summary>
            Abstract base class
            </summary>
        </member>
        <member name="P:AbinLibs.GenericThread.IsAlive">
            <summary>
            Check whether the thread is alive
            </summary>
        </member>
        <member name="P:AbinLibs.GenericThread.IsBackground">
            <summary>
            Get/set whether the thread is background
            </summary>
        </member>
        <member name="P:AbinLibs.GenericThread.Aborted">
            <summary>
            Check whether the thread was aborted (stopped by throwing a ThreadAbortException)
            </summary>
        </member>
        <member name="P:AbinLibs.GenericThread.ThreadState">
            <summary>
            Retrive thread state
            </summary>
        </member>
        <member name="M:AbinLibs.GenericThread.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:AbinLibs.GenericThread.Dispose">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="M:AbinLibs.GenericThread.Start">
            <summary>
            Start the thread
            </summary>
        </member>
        <member name="M:AbinLibs.GenericThread.Stop">
            <summary>
            Stop the thread
            </summary>
        </member>
        <member name="M:AbinLibs.GenericThread.Join">
            <summary>
            Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses
            </summary>
        </member>
        <member name="M:AbinLibs.GenericThread.Join(System.Int32)">
            <summary>
            Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait for the thread to terminate.</param>
            <returns>Return true if the thread has terminated before timeout, false otherwise</returns>
        </member>
        <member name="M:AbinLibs.GenericThread.Lock(System.Object)">
            <summary>
            Lock an object
            </summary>
            <param name="target">Object to be marked exclusive</param>
        </member>
        <member name="M:AbinLibs.GenericThread.Unlock(System.Object)">
            <summary>
            Unlock an object
            </summary>
            <param name="target">Object no longer exclusive</param>
        </member>
        <member name="M:AbinLibs.GenericThread.Sleep(System.Int32)">
            <summary>
            Sleep the thread
            </summary>
            <param name="milliseconds">Duration in milliseconds</param>
        </member>
        <member name="M:AbinLibs.GenericThread.GetWorkerProc">
            <summary>
            Abstract member to be overridden, derived classes must provider a ThreadStart to start the thread, such like "new ThreadStart(_ThreadProc)"
            </summary>
            <returns></returns>
        </member>
        <member name="T:AbinLibs.WorkerThread">
            <summary>
            A worker thread
            </summary>
        </member>
        <member name="M:AbinLibs.WorkerThread.OnStart">
            <summary>
            Called when the thread starts
            </summary>
        </member>
        <member name="M:AbinLibs.WorkerThread.OnStop">
            <summary>
            Called when the thread is stopped
            </summary>
        </member>
        <member name="M:AbinLibs.WorkerThread.ThreadProc">
            <summary>
            Thread working function
            </summary>
        </member>
        <member name="M:AbinLibs.WorkerThread.GetWorkerProc">
            <summary>
            Provide ThreadStart to base class
            </summary>
            <returns></returns>
        </member>
        <member name="M:AbinLibs.WorkerThread._ThreadProc">
            <summary>
            Internal thread process
            </summary>
        </member>
        <member name="T:AbinLibs.TickThread">
            <summary>
            A ticker thread
            </summary>
        </member>
        <member name="P:AbinLibs.TickThread.Interval">
            <summary>
            Interval between every 2 ticks, in milliseconds, default is 200 ms. Only set upon starting to ensure thread safe
            </summary>
        </member>
        <member name="M:AbinLibs.TickThread.Start(System.Int32)">
            <summary>
            Start ticking
            </summary>
            <param name="interval">Interval between every 2 ticks</param>
        </member>
        <member name="M:AbinLibs.TickThread.TickProc">
            <summary>
            Tick function, called every Interval
            </summary>
        </member>
        <member name="M:AbinLibs.TickThread.ThreadProc">
            <summary>
            Thread working function
            </summary>
        </member>
        <member name="T:AbinLibs.EventThread">
            <summary>
             An event thread
            </summary>
        </member>
        <member name="P:AbinLibs.EventThread.OnStart">
            <summary>
            Called when the thread starts
            </summary>
        </member>
        <member name="P:AbinLibs.EventThread.OnStop">
            <summary>
            Called when the thread is stopped
            </summary>
        </member>
        <member name="P:AbinLibs.EventThread.ThreadProc">
            <summary>
            Thread working function
            </summary>
        </member>
        <member name="M:AbinLibs.EventThread.GetWorkerProc">
            <summary>
            Obtain the4 worker proc function
            </summary>
            <returns></returns>
        </member>
        <member name="M:AbinLibs.EventThread._ThreadProc">
            <summary>
            Internal thread process
            </summary>
        </member>
        <member name="T:AbinLibs.TickEventThread">
            <summary>
            An event ticker thread
            </summary>
        </member>
        <member name="P:AbinLibs.TickEventThread.OnTick">
            <summary>
            Called on every tick 
            </summary>
        </member>
        <member name="P:AbinLibs.TickEventThread.Interval">
            <summary>
            Interval between every 2 ticks, in milliseconds, default is 200 ms. Only set upon starting to ensure thread safe
            </summary>
        </member>
        <member name="M:AbinLibs.TickEventThread.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AbinLibs.TickEventThread.Start(System.Int32)">
            <summary>
            Start the tick thread
            </summary>
            <param name="interval">Interval between every 2 ticks, in milliseconds</param>
        </member>
        <member name="M:AbinLibs.TickEventThread._TickThreadProc">
            <summary>
            Internal tick process
            </summary>
        </member>
        <member name="T:AbinLibs.EventThreadHandler">
            <summary>
            Type definition of event callback functions
            </summary>
        </member>
    </members>
</doc>
